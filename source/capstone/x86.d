module capstone.x86;

import capstone.internal.x86;

import std.variant;
import std.exception: enforce;

// Instruction's operand referring to memory
// This is associated with X86_OP_MEM operand type above
struct Mem {
	X86Register segment; // segment register (or X86_REG_INVALID if irrelevant)
	X86Register base;	// base register (or X86_REG_INVALID if irrelevant)
	X86Register index;	// index register (or X86_REG_INVALID if irrelevant)
	int scale;	// scale for index register
	long disp;	// displacement value
}

alias X86OperandValue = Algebraic!(X86Register, long, Mem, double);

// Instruction operand
struct X86Operand {
	X86OperandType type;
	// TODO: hide?
	X86OperandValue value;

    // size of this operand (in bytes)
    ubyte size;

    // AVX broadcast type, or 0 if irrelevant
    X86AvxBroadcast avxBcast;

    // AVX zero opmask {z}
    bool avxZeroOpmask;

	// TODO: Should not be visible
	this(cs_x86_op internal){
		type = internal.type;
		final switch(internal.type) {
			case X86OperandType.invalid:
				break;
			case X86OperandType.register:
				value = internal.reg;
				break;
			case X86OperandType.immediate:
				value = internal.imm;
				break;
			case X86OperandType.memory:
				value = internal.mem;
				break;
			case X86OperandType.floatingPoint:
				value = internal.fp;
				break;
		}
		size = internal.size;
		avxBcast = internal.avx_bcast;
		avxZeroOpmask = internal.avx_zero_opmask;
	}

	// TODO: enforces ok?
	@property auto regValue() const {
		enforce(value.type == typeid(X86Register));
		return value.get!(X86Register);
	}
	@property auto immValue() const {
		enforce(value.type == typeid(long));
		return value.get!(long);
	}
	@property auto memValue() const {
		enforce(value.type == typeid(Mem));
		return value.get!(Mem);
	}
	@property auto fpValue() const {
		enforce(value.type == typeid(float));
		return value.get!(float);
	}
}

// Instruction structure
struct X86InstructionDetail {
	// Instruction prefix, which can be up to 4 bytes.
	// A prefix byte gets value 0 when irrelevant.
	// prefix[0] indicates REP/REPNE/LOCK prefix (See X86_PREFIX_REP/REPNE/LOCK above)
	// prefix[1] indicates segment override (irrelevant for x86_64):
	// See X86_PREFIX_CS/SS/DS/ES/FS/GS above.
	// prefix[2] indicates operand-size override (X86_PREFIX_OPSIZE)
	// prefix[3] indicates address-size override (X86_PREFIX_ADDRSIZE)
	ubyte[] prefix;

	// Instruction opcode, wich can be from 1 to 4 bytes in size.
	// This contains VEX opcode as well.
	// An trailing opcode byte gets value 0 when irrelevant.
	ubyte[] opcode;

	// REX prefix: only a non-zero value is relavant for x86_64
	ubyte rex;

	// Address size, which can be overrided with above prefix[5].
	ubyte addrSize;

	// ModR/M byte
	ubyte modRM;

	// SIB value, or 0 when irrelevant.
	ubyte sib;

	// Displacement value, or 0 when irrelevant.
	int disp;

	/* SIB state */
	// SIB index register, or X86_REG_INVALID when irrelevant.
	X86Register sibIndex;
	// SIB scale. only applicable if sib_index is relavant.
	byte sibScale;
	// SIB base register, or X86_REG_INVALID when irrelevant.
	X86Register sibBase;

	// SSE Code Condition
	X86SseCodeCondition sseCc;
	// AVX Code Condition
	X86AvxCodeCondition avxCc;
	// AVX Suppress all Exception
	bool avxSae;
	// AVX static rounding mode
	X86AvxRoundingMode avxRM;

	X86Operand[] operands;	// operands for this instruction.

	// TODO: Check for copying/ownership issues
	// TODO: Should not be visible
	this(cs_x86 internal){
		prefix = internal.prefix.dup; // here [0..?]
		opcode = internal.opcode.dup; // here [0..?]
		rex = internal.rex;
		addrSize = internal.addr_size;
		modRM = internal.modrm;
		sib = internal.sib;
		disp = internal.disp;
		sibIndex = internal.sib_index;
		sibScale = internal.sib_scale;
		sibBase = internal.sib_base;
		sseCc = internal.sse_cc;
		avxCc = internal.avx_cc;
		avxRM = internal.avx_rm;

		foreach(op; internal.operands[0..internal.op_count])
			operands ~= X86Operand(op);
	}
}

///////////////////////////////////////////////////////////////////////////////
// Constants
///////////////////////////////////////////////////////////////////////////////

//> X86 registers
enum X86Register {
	invalid = 0,
	ah, al, ax, bh, bl,
	bp, bpl, bx, ch, cl,
	cs, cx, dh, di, dil,
	dl, ds, dx, eax, ebp,
	ebx, ecx, edi, edx, eflags,
	eip, eiz, es, esi, esp,
	fpsw, fs, gs, ip, rax,
	rbp, rbx, rcx, rdi, rdx,
	rip, riz, rsi, rsp, si,
	sil, sp, spl, ss, cr0,
	cr1, cr2, cr3, cr4, cr5,
	cr6, cr7, cr8, cr9, cr10,
	cr11, cr12, cr13, cr14, cr15,
	dr0, dr1, dr2, dr3, dr4,
	dr5, dr6, dr7, fp0, fp1,
	fp2, fp3, fp4, fp5, fp6, fp7,
	k0, k1, k2, k3, k4,
	k5, k6, k7, mm0, mm1,
	mm2, mm3, mm4, mm5, mm6,
	mm7, r8, r9, r10, r11,
	r12, r13, r14, r15,
	st0, st1, st2, st3,
	st4, st5, st6, st7,
	xmm0, xmm1, xmm2, xmm3, xmm4,
	xmm5, xmm6, xmm7, xmm8, xmm9,
	xmm10, xmm11, xmm12, xmm13, xmm14,
	xmm15, xmm16, xmm17, xmm18, xmm19,
	xmm20, xmm21, xmm22, xmm23, xmm24,
	xmm25, xmm26, xmm27, xmm28, xmm29,
	xmm30, xmm31, ymm0, ymm1, ymm2,
	ymm3, ymm4, ymm5, ymm6, ymm7,
	ymm8, ymm9, ymm10, ymm11, ymm12,
	ymm13, ymm14, ymm15, ymm16, ymm17,
	ymm18, ymm19, ymm20, ymm21, ymm22,
	ymm23, ymm24, ymm25, ymm26, ymm27,
	ymm28, ymm29, ymm30, ymm31, zmm0,
	zmm1, zmm2, zmm3, zmm4, zmm5,
	zmm6, zmm7, zmm8, zmm9, zmm10,
	zmm11, zmm12, zmm13, zmm14, zmm15,
	zmm16, zmm17, zmm18, zmm19, zmm20,
	zmm21, zmm22, zmm23, zmm24, zmm25,
	zmm26, zmm27, zmm28, zmm29, zmm30,
	zmm31, r8b, r9b, r10b, r11b,
	r12b, r13b, r14b, r15b, r8d,
	r9d, r10d, r11d, r12d, r13d,
	r14d, r15d, r8w, r9w, r10w,
	r11w, r12w, r13w, r14w, r15w
}

//> Operand type for instruction's operands
enum X86OperandType {
	invalid = 0, // = CS_OP_INVALID (Uninitialized).
	register, // = CS_OP_REG (Register operand).
	immediate, // = CS_OP_IMM (Immediate operand).
	memory, // = CS_OP_MEM (Memory operand).
	floatingPoint  //  = CS_OP_FP  (Floating-Point operand).
}

//> AVX broadcast type
enum X86AvxBroadcast {
	invalid = 0,	// uninitialized.
	bcast_2,	// avx512 broadcast type {1to2}
	bcast_4,	// avx512 broadcast type {1to4}
	bcast_8,	// avx512 broadcast type {1to8}
	bcast_16	// avx512 broadcast type {1to16}
}

//> SSE Code Condition type
enum X86SseCodeCondition {
	invalid = 0,	// uninitialized.
	eq,
	lt,
	le,
	unord,
	neq,
	nlt,
	nle,
	ord,
	eq_uq,
	nge,
	ngt,
	false_,
	neq_oq,
	ge,
	gt,
	true_
}

//> AVX Code Condition type
enum X86AvxCodeCondition {
	invalid = 0,	// uninitialized.
	eq,
	lt,
	le,
	unord,
	neq,
	nlt,
	nle,
	ord,
	eq_uq,
	nge,
	ngt,
	false_,
	neq_oq,
	ge,
	gt,
	true_,
	eq_os,
	lt_oq,
	le_oq,
	unord_s,
	neq_us,
	nlt_uq,
	nle_uq,
	ord_s,
	eq_us,
	nge_uq,
	ngt_uq,
	false_os,
	neq_os,
	ge_oq,
	gt_oq,
	true_us
}

//> AVX static rounding mode type
enum X86AvxRoundingMode {
	invalid = 0,	// uninitialized.
	rn,	// round to nearest
	rd,	// round down
	ru,	// round up
	rz	// round toward zero
}

//> Instruction prefixes - to be used in cs_x86.prefix[]
enum X86Prefix {
	lock		= 	0xf0,	// lock (cs_x86.prefix[0]
	rep		= 	0xf3,	// rep (cs_x86.prefix[0]
	repne	= 	0xf2,	// repne (cs_x86.prefix[0]

	cs		= 	0x2e,	// segment override cs (cs_x86.prefix[1]
	ss		= 	0x36,	// segment override ss (cs_x86.prefix[1]
	ds		= 	0x3e,	// segment override ds (cs_x86.prefix[1]
	es		= 	0x26,	// segment override es (cs_x86.prefix[1]
	fs		= 	0x64,	// segment override fs (cs_x86.prefix[1]
	gs		= 	0x65,	// segment override gs (cs_x86.prefix[1]

	opsize	=	0x66,	// operand-size override (cs_x86.prefix[2]
	addrsize	=	0x67	// address-size override (cs_x86.prefix[3]
}

//> X86 instructions
enum X86InstructionId {
	invalid = 0,

	aaa,
	aad,
	aam,
	aas,
	fabs,
	adc,
	adcx,
	add,
	addpd,
	addps,
	addsd,
	addss,
	addsubpd,
	addsubps,
	fadd,
	fiadd,
	faddp,
	adox,
	aesdeclast,
	aesdec,
	aesenclast,
	aesenc,
	aesimc,
	aeskeygenassist,
	and,
	andn,
	andnpd,
	andnps,
	andpd,
	andps,
	arpl,
	bextr,
	blcfill,
	blci,
	blcic,
	blcmsk,
	blcs,
	blendpd,
	blendps,
	blendvpd,
	blendvps,
	blsfill,
	blsi,
	blsic,
	blsmsk,
	blsr,
	bound,
	bsf,
	bsr,
	bswap,
	bt,
	btc,
	btr,
	bts,
	bzhi,
	call,
	cbw,
	cdq,
	cdqe,
	fchs,
	clac,
	clc,
	cld,
	clflush,
	clgi,
	cli,
	clts,
	cmc,
	cmova,
	cmovae,
	cmovb,
	cmovbe,
	fcmovbe,
	fcmovb,
	cmove,
	fcmove,
	cmovg,
	cmovge,
	cmovl,
	cmovle,
	fcmovnbe,
	fcmovnb,
	cmovne,
	fcmovne,
	cmovno,
	cmovnp,
	fcmovnu,
	cmovns,
	cmovo,
	cmovp,
	fcmovu,
	cmovs,
	cmp,
	cmppd,
	cmpps,
	cmpsb,
	cmpsd,
	cmpsq,
	cmpss,
	cmpsw,
	cmpxchg16b,
	cmpxchg,
	cmpxchg8b,
	comisd,
	comiss,
	fcomp,
	fcompi,
	fcomi,
	fcom,
	fcos,
	cpuid,
	cqo,
	crc32,
	cvtdq2pd,
	cvtdq2ps,
	cvtpd2dq,
	cvtpd2ps,
	cvtps2dq,
	cvtps2pd,
	cvtsd2si,
	cvtsd2ss,
	cvtsi2sd,
	cvtsi2ss,
	cvtss2sd,
	cvtss2si,
	cvttpd2dq,
	cvttps2dq,
	cvttsd2si,
	cvttss2si,
	cwd,
	cwde,
	daa,
	das,
	data16,
	dec,
	div,
	divpd,
	divps,
	fdivr,
	fidivr,
	fdivrp,
	divsd,
	divss,
	fdiv,
	fidiv,
	fdivp,
	dppd,
	dpps,
	ret,
	encls,
	enclu,
	enter,
	extractps,
	extrq,
	f2xm1,
	lcall,
	ljmp,
	fbld,
	fbstp,
	fcompp,
	fdecstp,
	femms,
	ffree,
	ficom,
	ficomp,
	fincstp,
	fldcw,
	fldenv,
	fldl2e,
	fldl2t,
	fldlg2,
	fldln2,
	fldpi,
	fnclex,
	fninit,
	fnop,
	fnstcw,
	fnstsw,
	fpatan,
	fprem,
	fprem1,
	fptan,
	frndint,
	frstor,
	fnsave,
	fscale,
	fsetpm,
	fsincos,
	fnstenv,
	fxam,
	fxrstor,
	fxrstor64,
	fxsave,
	fxsave64,
	fxtract,
	fyl2x,
	fyl2xp1,
	movapd,
	movaps,
	orpd,
	orps,
	vmovapd,
	vmovaps,
	xorpd,
	xorps,
	getsec,
	haddpd,
	haddps,
	hlt,
	hsubpd,
	hsubps,
	idiv,
	fild,
	imul,
	in_,
	inc,
	insb,
	insertps,
	insertq,
	insd,
	insw,
	int_,
	int1,
	int3,
	into,
	invd,
	invept,
	invlpg,
	invlpga,
	invpcid,
	invvpid,
	iret,
	iretd,
	iretq,
	fisttp,
	fist,
	fistp,
	ucomisd,
	ucomiss,
	vcmp,
	vcomisd,
	vcomiss,
	vcvtsd2ss,
	vcvtsi2sd,
	vcvtsi2ss,
	vcvtss2sd,
	vcvttsd2si,
	vcvttsd2usi,
	vcvttss2si,
	vcvttss2usi,
	vcvtusi2sd,
	vcvtusi2ss,
	vucomisd,
	vucomiss,
	jae,
	ja,
	jbe,
	jb,
	jcxz,
	jecxz,
	je,
	jge,
	jg,
	jle,
	jl,
	jmp,
	jne,
	jno,
	jnp,
	jns,
	jo,
	jp,
	jrcxz,
	js,
	kandb,
	kandd,
	kandnb,
	kandnd,
	kandnq,
	kandnw,
	kandq,
	kandw,
	kmovb,
	kmovd,
	kmovq,
	kmovw,
	knotb,
	knotd,
	knotq,
	knotw,
	korb,
	kord,
	korq,
	kortestw,
	korw,
	kshiftlw,
	kshiftrw,
	kunpckbw,
	kxnorb,
	kxnord,
	kxnorq,
	kxnorw,
	kxorb,
	kxord,
	kxorq,
	kxorw,
	lahf,
	lar,
	lddqu,
	ldmxcsr,
	lds,
	fldz,
	fld1,
	fld,
	lea,
	leave,
	les,
	lfence,
	lfs,
	lgdt,
	lgs,
	lidt,
	lldt,
	lmsw,
	or,
	sub,
	xor,
	lodsb,
	lodsd,
	lodsq,
	lodsw,
	loop,
	loope,
	loopne,
	retf,
	retfq,
	lsl,
	lss,
	ltr,
	xadd,
	lzcnt,
	maskmovdqu,
	maxpd,
	maxps,
	maxsd,
	maxss,
	mfence,
	minpd,
	minps,
	minsd,
	minss,
	cvtpd2pi,
	cvtpi2pd,
	cvtpi2ps,
	cvtps2pi,
	cvttpd2pi,
	cvttps2pi,
	emms,
	maskmovq,
	movd,
	movdq2q,
	movntq,
	movq2dq,
	movq,
	pabsb,
	pabsd,
	pabsw,
	packssdw,
	packsswb,
	packuswb,
	paddb,
	paddd,
	paddq,
	paddsb,
	paddsw,
	paddusb,
	paddusw,
	paddw,
	palignr,
	pandn,
	pand,
	pavgb,
	pavgw,
	pcmpeqb,
	pcmpeqd,
	pcmpeqw,
	pcmpgtb,
	pcmpgtd,
	pcmpgtw,
	pextrw,
	phaddsw,
	phaddw,
	phaddd,
	phsubd,
	phsubsw,
	phsubw,
	pinsrw,
	pmaddubsw,
	pmaddwd,
	pmaxsw,
	pmaxub,
	pminsw,
	pminub,
	pmovmskb,
	pmulhrsw,
	pmulhuw,
	pmulhw,
	pmullw,
	pmuludq,
	por,
	psadbw,
	pshufb,
	pshufw,
	psignb,
	psignd,
	psignw,
	pslld,
	psllq,
	psllw,
	psrad,
	psraw,
	psrld,
	psrlq,
	psrlw,
	psubb,
	psubd,
	psubq,
	psubsb,
	psubsw,
	psubusb,
	psubusw,
	psubw,
	punpckhbw,
	punpckhdq,
	punpckhwd,
	punpcklbw,
	punpckldq,
	punpcklwd,
	pxor,
	monitor,
	montmul,
	mov,
	movabs,
	movbe,
	movddup,
	movdqa,
	movdqu,
	movhlps,
	movhpd,
	movhps,
	movlhps,
	movlpd,
	movlps,
	movmskpd,
	movmskps,
	movntdqa,
	movntdq,
	movnti,
	movntpd,
	movntps,
	movntsd,
	movntss,
	movsb,
	movsd,
	movshdup,
	movsldup,
	movsq,
	movss,
	movsw,
	movsx,
	movsxd,
	movupd,
	movups,
	movzx,
	mpsadbw,
	mul,
	mulpd,
	mulps,
	mulsd,
	mulss,
	mulx,
	fmul,
	fimul,
	fmulp,
	mwait,
	neg,
	nop,
	not,
	out_,
	outsb,
	outsd,
	outsw,
	packusdw,
	pause,
	pavgusb,
	pblendvb,
	pblendw,
	pclmulqdq,
	pcmpeqq,
	pcmpestri,
	pcmpestrm,
	pcmpgtq,
	pcmpistri,
	pcmpistrm,
	pdep,
	pext,
	pextrb,
	pextrd,
	pextrq,
	pf2id,
	pf2iw,
	pfacc,
	pfadd,
	pfcmpeq,
	pfcmpge,
	pfcmpgt,
	pfmax,
	pfmin,
	pfmul,
	pfnacc,
	pfpnacc,
	pfrcpit1,
	pfrcpit2,
	pfrcp,
	pfrsqit1,
	pfrsqrt,
	pfsubr,
	pfsub,
	phminposuw,
	pi2fd,
	pi2fw,
	pinsrb,
	pinsrd,
	pinsrq,
	pmaxsb,
	pmaxsd,
	pmaxud,
	pmaxuw,
	pminsb,
	pminsd,
	pminud,
	pminuw,
	pmovsxbd,
	pmovsxbq,
	pmovsxbw,
	pmovsxdq,
	pmovsxwd,
	pmovsxwq,
	pmovzxbd,
	pmovzxbq,
	pmovzxbw,
	pmovzxdq,
	pmovzxwd,
	pmovzxwq,
	pmuldq,
	pmulhrw,
	pmulld,
	pop,
	popaw,
	popal,
	popcnt,
	popf,
	popfd,
	popfq,
	prefetch,
	prefetchnta,
	prefetcht0,
	prefetcht1,
	prefetcht2,
	prefetchw,
	pshufd,
	pshufhw,
	pshuflw,
	pslldq,
	psrldq,
	pswapd,
	ptest,
	punpckhqdq,
	punpcklqdq,
	push,
	pushaw,
	pushal,
	pushf,
	pushfd,
	pushfq,
	rcl,
	rcpps,
	rcpss,
	rcr,
	rdfsbase,
	rdgsbase,
	rdmsr,
	rdpmc,
	rdrand,
	rdseed,
	rdtsc,
	rdtscp,
	rol,
	ror,
	rorx,
	roundpd,
	roundps,
	roundsd,
	roundss,
	rsm,
	rsqrtps,
	rsqrtss,
	sahf,
	sal,
	salc,
	sar,
	sarx,
	sbb,
	scasb,
	scasd,
	scasq,
	scasw,
	setae,
	seta,
	setbe,
	setb,
	sete,
	setge,
	setg,
	setle,
	setl,
	setne,
	setno,
	setnp,
	setns,
	seto,
	setp,
	sets,
	sfence,
	sgdt,
	sha1msg1,
	sha1msg2,
	sha1nexte,
	sha1rnds4,
	sha256msg1,
	sha256msg2,
	sha256rnds2,
	shl,
	shld,
	shlx,
	shr,
	shrd,
	shrx,
	shufpd,
	shufps,
	sidt,
	fsin,
	skinit,
	sldt,
	smsw,
	sqrtpd,
	sqrtps,
	sqrtsd,
	sqrtss,
	fsqrt,
	stac,
	stc,
	std,
	stgi,
	sti,
	stmxcsr,
	stosb,
	stosd,
	stosq,
	stosw,
	str,
	fst,
	fstp,
	fstpnce,
	subpd,
	subps,
	fsubr,
	fisubr,
	fsubrp,
	subsd,
	subss,
	fsub,
	fisub,
	fsubp,
	swapgs,
	syscall,
	sysenter,
	sysexit,
	sysret,
	t1mskc,
	test,
	ud2,
	ftst,
	tzcnt,
	tzmsk,
	fucompi,
	fucomi,
	fucompp,
	fucomp,
	fucom,
	ud2b,
	unpckhpd,
	unpckhps,
	unpcklpd,
	unpcklps,
	vaddpd,
	vaddps,
	vaddsd,
	vaddss,
	vaddsubpd,
	vaddsubps,
	vaesdeclast,
	vaesdec,
	vaesenclast,
	vaesenc,
	vaesimc,
	vaeskeygenassist,
	valignd,
	valignq,
	vandnpd,
	vandnps,
	vandpd,
	vandps,
	vblendmpd,
	vblendmps,
	vblendpd,
	vblendps,
	vblendvpd,
	vblendvps,
	vbroadcastf128,
	vbroadcasti128,
	vbroadcasti32x4,
	vbroadcasti64x4,
	vbroadcastsd,
	vbroadcastss,
	vcmppd,
	vcmpps,
	vcmpsd,
	vcmpss,
	vcvtdq2pd,
	vcvtdq2ps,
	vcvtpd2dqx,
	vcvtpd2dq,
	vcvtpd2psx,
	vcvtpd2ps,
	vcvtpd2udq,
	vcvtph2ps,
	vcvtps2dq,
	vcvtps2pd,
	vcvtps2ph,
	vcvtps2udq,
	vcvtsd2si,
	vcvtsd2usi,
	vcvtss2si,
	vcvtss2usi,
	vcvttpd2dqx,
	vcvttpd2dq,
	vcvttpd2udq,
	vcvttps2dq,
	vcvttps2udq,
	vcvtudq2pd,
	vcvtudq2ps,
	vdivpd,
	vdivps,
	vdivsd,
	vdivss,
	vdppd,
	vdpps,
	verr,
	verw,
	vextractf128,
	vextractf32x4,
	vextractf64x4,
	vextracti128,
	vextracti32x4,
	vextracti64x4,
	vextractps,
	vfmadd132pd,
	vfmadd132ps,
	vfmadd213pd,
	vfmadd213ps,
	vfmaddpd,
	vfmadd231pd,
	vfmaddps,
	vfmadd231ps,
	vfmaddsd,
	vfmadd213sd,
	vfmadd132sd,
	vfmadd231sd,
	vfmaddss,
	vfmadd213ss,
	vfmadd132ss,
	vfmadd231ss,
	vfmaddsub132pd,
	vfmaddsub132ps,
	vfmaddsub213pd,
	vfmaddsub213ps,
	vfmaddsubpd,
	vfmaddsub231pd,
	vfmaddsubps,
	vfmaddsub231ps,
	vfmsub132pd,
	vfmsub132ps,
	vfmsub213pd,
	vfmsub213ps,
	vfmsubadd132pd,
	vfmsubadd132ps,
	vfmsubadd213pd,
	vfmsubadd213ps,
	vfmsubaddpd,
	vfmsubadd231pd,
	vfmsubaddps,
	vfmsubadd231ps,
	vfmsubpd,
	vfmsub231pd,
	vfmsubps,
	vfmsub231ps,
	vfmsubsd,
	vfmsub213sd,
	vfmsub132sd,
	vfmsub231sd,
	vfmsubss,
	vfmsub213ss,
	vfmsub132ss,
	vfmsub231ss,
	vfnmadd132pd,
	vfnmadd132ps,
	vfnmadd213pd,
	vfnmadd213ps,
	vfnmaddpd,
	vfnmadd231pd,
	vfnmaddps,
	vfnmadd231ps,
	vfnmaddsd,
	vfnmadd213sd,
	vfnmadd132sd,
	vfnmadd231sd,
	vfnmaddss,
	vfnmadd213ss,
	vfnmadd132ss,
	vfnmadd231ss,
	vfnmsub132pd,
	vfnmsub132ps,
	vfnmsub213pd,
	vfnmsub213ps,
	vfnmsubpd,
	vfnmsub231pd,
	vfnmsubps,
	vfnmsub231ps,
	vfnmsubsd,
	vfnmsub213sd,
	vfnmsub132sd,
	vfnmsub231sd,
	vfnmsubss,
	vfnmsub213ss,
	vfnmsub132ss,
	vfnmsub231ss,
	vfrczpd,
	vfrczps,
	vfrczsd,
	vfrczss,
	vorpd,
	vorps,
	vxorpd,
	vxorps,
	vgatherdpd,
	vgatherdps,
	vgatherpf0dpd,
	vgatherpf0dps,
	vgatherpf0qpd,
	vgatherpf0qps,
	vgatherpf1dpd,
	vgatherpf1dps,
	vgatherpf1qpd,
	vgatherpf1qps,
	vgatherqpd,
	vgatherqps,
	vhaddpd,
	vhaddps,
	vhsubpd,
	vhsubps,
	vinsertf128,
	vinsertf32x4,
	vinsertf64x4,
	vinserti128,
	vinserti32x4,
	vinserti64x4,
	vinsertps,
	vlddqu,
	vldmxcsr,
	vmaskmovdqu,
	vmaskmovpd,
	vmaskmovps,
	vmaxpd,
	vmaxps,
	vmaxsd,
	vmaxss,
	vmcall,
	vmclear,
	vmfunc,
	vminpd,
	vminps,
	vminsd,
	vminss,
	vmlaunch,
	vmload,
	vmmcall,
	vmovq,
	vmovddup,
	vmovd,
	vmovdqa32,
	vmovdqa64,
	vmovdqa,
	vmovdqu16,
	vmovdqu32,
	vmovdqu64,
	vmovdqu8,
	vmovdqu,
	vmovhlps,
	vmovhpd,
	vmovhps,
	vmovlhps,
	vmovlpd,
	vmovlps,
	vmovmskpd,
	vmovmskps,
	vmovntdqa,
	vmovntdq,
	vmovntpd,
	vmovntps,
	vmovsd,
	vmovshdup,
	vmovsldup,
	vmovss,
	vmovupd,
	vmovups,
	vmpsadbw,
	vmptrld,
	vmptrst,
	vmread,
	vmresume,
	vmrun,
	vmsave,
	vmulpd,
	vmulps,
	vmulsd,
	vmulss,
	vmwrite,
	vmxoff,
	vmxon,
	vpabsb,
	vpabsd,
	vpabsq,
	vpabsw,
	vpackssdw,
	vpacksswb,
	vpackusdw,
	vpackuswb,
	vpaddb,
	vpaddd,
	vpaddq,
	vpaddsb,
	vpaddsw,
	vpaddusb,
	vpaddusw,
	vpaddw,
	vpalignr,
	vpandd,
	vpandnd,
	vpandnq,
	vpandn,
	vpandq,
	vpand,
	vpavgb,
	vpavgw,
	vpblendd,
	vpblendmd,
	vpblendmq,
	vpblendvb,
	vpblendw,
	vpbroadcastb,
	vpbroadcastd,
	vpbroadcastmb2q,
	vpbroadcastmw2d,
	vpbroadcastq,
	vpbroadcastw,
	vpclmulqdq,
	vpcmov,
	vpcmp,
	vpcmpd,
	vpcmpeqb,
	vpcmpeqd,
	vpcmpeqq,
	vpcmpeqw,
	vpcmpestri,
	vpcmpestrm,
	vpcmpgtb,
	vpcmpgtd,
	vpcmpgtq,
	vpcmpgtw,
	vpcmpistri,
	vpcmpistrm,
	vpcmpq,
	vpcmpud,
	vpcmpuq,
	vpcomb,
	vpcomd,
	vpcomq,
	vpcomub,
	vpcomud,
	vpcomuq,
	vpcomuw,
	vpcomw,
	vpconflictd,
	vpconflictq,
	vperm2f128,
	vperm2i128,
	vpermd,
	vpermi2d,
	vpermi2pd,
	vpermi2ps,
	vpermi2q,
	vpermil2pd,
	vpermil2ps,
	vpermilpd,
	vpermilps,
	vpermpd,
	vpermps,
	vpermq,
	vpermt2d,
	vpermt2pd,
	vpermt2ps,
	vpermt2q,
	vpextrb,
	vpextrd,
	vpextrq,
	vpextrw,
	vpgatherdd,
	vpgatherdq,
	vpgatherqd,
	vpgatherqq,
	vphaddbd,
	vphaddbq,
	vphaddbw,
	vphadddq,
	vphaddd,
	vphaddsw,
	vphaddubd,
	vphaddubq,
	vphaddubw,
	vphaddudq,
	vphadduwd,
	vphadduwq,
	vphaddwd,
	vphaddwq,
	vphaddw,
	vphminposuw,
	vphsubbw,
	vphsubdq,
	vphsubd,
	vphsubsw,
	vphsubwd,
	vphsubw,
	vpinsrb,
	vpinsrd,
	vpinsrq,
	vpinsrw,
	vplzcntd,
	vplzcntq,
	vpmacsdd,
	vpmacsdqh,
	vpmacsdql,
	vpmacssdd,
	vpmacssdqh,
	vpmacssdql,
	vpmacsswd,
	vpmacssww,
	vpmacswd,
	vpmacsww,
	vpmadcsswd,
	vpmadcswd,
	vpmaddubsw,
	vpmaddwd,
	vpmaskmovd,
	vpmaskmovq,
	vpmaxsb,
	vpmaxsd,
	vpmaxsq,
	vpmaxsw,
	vpmaxub,
	vpmaxud,
	vpmaxuq,
	vpmaxuw,
	vpminsb,
	vpminsd,
	vpminsq,
	vpminsw,
	vpminub,
	vpminud,
	vpminuq,
	vpminuw,
	vpmovdb,
	vpmovdw,
	vpmovmskb,
	vpmovqb,
	vpmovqd,
	vpmovqw,
	vpmovsdb,
	vpmovsdw,
	vpmovsqb,
	vpmovsqd,
	vpmovsqw,
	vpmovsxbd,
	vpmovsxbq,
	vpmovsxbw,
	vpmovsxdq,
	vpmovsxwd,
	vpmovsxwq,
	vpmovusdb,
	vpmovusdw,
	vpmovusqb,
	vpmovusqd,
	vpmovusqw,
	vpmovzxbd,
	vpmovzxbq,
	vpmovzxbw,
	vpmovzxdq,
	vpmovzxwd,
	vpmovzxwq,
	vpmuldq,
	vpmulhrsw,
	vpmulhuw,
	vpmulhw,
	vpmulld,
	vpmullw,
	vpmuludq,
	vpord,
	vporq,
	vpor,
	vpperm,
	vprotb,
	vprotd,
	vprotq,
	vprotw,
	vpsadbw,
	vpscatterdd,
	vpscatterdq,
	vpscatterqd,
	vpscatterqq,
	vpshab,
	vpshad,
	vpshaq,
	vpshaw,
	vpshlb,
	vpshld,
	vpshlq,
	vpshlw,
	vpshufb,
	vpshufd,
	vpshufhw,
	vpshuflw,
	vpsignb,
	vpsignd,
	vpsignw,
	vpslldq,
	vpslld,
	vpsllq,
	vpsllvd,
	vpsllvq,
	vpsllw,
	vpsrad,
	vpsraq,
	vpsravd,
	vpsravq,
	vpsraw,
	vpsrldq,
	vpsrld,
	vpsrlq,
	vpsrlvd,
	vpsrlvq,
	vpsrlw,
	vpsubb,
	vpsubd,
	vpsubq,
	vpsubsb,
	vpsubsw,
	vpsubusb,
	vpsubusw,
	vpsubw,
	vptestmd,
	vptestmq,
	vptestnmd,
	vptestnmq,
	vptest,
	vpunpckhbw,
	vpunpckhdq,
	vpunpckhqdq,
	vpunpckhwd,
	vpunpcklbw,
	vpunpckldq,
	vpunpcklqdq,
	vpunpcklwd,
	vpxord,
	vpxorq,
	vpxor,
	vrcp14pd,
	vrcp14ps,
	vrcp14sd,
	vrcp14ss,
	vrcp28pd,
	vrcp28ps,
	vrcp28sd,
	vrcp28ss,
	vrcpps,
	vrcpss,
	vrndscalepd,
	vrndscaleps,
	vrndscalesd,
	vrndscaless,
	vroundpd,
	vroundps,
	vroundsd,
	vroundss,
	vrsqrt14pd,
	vrsqrt14ps,
	vrsqrt14sd,
	vrsqrt14ss,
	vrsqrt28pd,
	vrsqrt28ps,
	vrsqrt28sd,
	vrsqrt28ss,
	vrsqrtps,
	vrsqrtss,
	vscatterdpd,
	vscatterdps,
	vscatterpf0dpd,
	vscatterpf0dps,
	vscatterpf0qpd,
	vscatterpf0qps,
	vscatterpf1dpd,
	vscatterpf1dps,
	vscatterpf1qpd,
	vscatterpf1qps,
	vscatterqpd,
	vscatterqps,
	vshufpd,
	vshufps,
	vsqrtpd,
	vsqrtps,
	vsqrtsd,
	vsqrtss,
	vstmxcsr,
	vsubpd,
	vsubps,
	vsubsd,
	vsubss,
	vtestpd,
	vtestps,
	vunpckhpd,
	vunpckhps,
	vunpcklpd,
	vunpcklps,
	vzeroall,
	vzeroupper,
	wait,
	wbinvd,
	wrfsbase,
	wrgsbase,
	wrmsr,
	xabort,
	xacquire,
	xbegin,
	xchg,
	fxch,
	xcryptcbc,
	xcryptcfb,
	xcryptctr,
	xcryptecb,
	xcryptofb,
	xend,
	xgetbv,
	xlatb,
	xrelease,
	xrstor,
	xrstor64,
	xsave,
	xsave64,
	xsaveopt,
	xsaveopt64,
	xsetbv,
	xsha1,
	xsha256,
	xstore,
	xtest
}

//> Group of X86 instructions
enum  X86InstructionGroup {
	invalid = 0, // = cs_grp_invalid

	//> generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	jump,	// = cs_grp_jump
	// all call instructions
	call,	// = cs_grp_call
	// all return instructions
	ret,	// = cs_grp_ret
	// all interrupt instructions (int+syscall)
	int_,	// = cs_grp_int
	// all interrupt return instructions
	iret,	// = cs_grp_iret

	//> architecture-specific groups
	vm = 128,	// all virtualization instructions (vt-x + amd-v)
	grp_3dnow,
	aes,
	adx,
	avx,
	avx2,
	avx512,
	bmi,
	bmi2,
	cmov,
	f16c,
	fma,
	fma4,
	fsgsbase,
	hle,
	mmx,
	mode32,
	mode64,
	rtm,
	sha,
	sse1,
	sse2,
	sse3,
	sse41,
	sse42,
	sse4a,
	ssse3,
	pclmul,
	xop,
	cdi,
	eri,
	tbm,
	grp_16bitmode,
	not64bitmode,
	sgx,
	dqi,
	bwi,
	pfi,
	vlx,
	smap,
	novlx
}