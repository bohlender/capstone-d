/// Types and constants of MIPS architecture
module capstone.mips;

import std.variant;
import std.exception: enforce;

import capstone.internal;
import capstone.utils;

/** Instruction's operand referring to memory

This is associated with the `MipsOpType.mem` operand type
*/
struct MipsOpMem {
    MipsRegister base;   /// Base register (or `MipsRegister.invalid` if irrelevant)
    long disp;           /// Displacement value
}

/// Tagged union of possible operand types
alias MipsOpValue = TaggedUnion!(MipsRegister, "reg", long, "imm", MipsOpMem, "mem");

/// Instruction's operand
struct MipsOp {
    MipsOpType type;   /// Operand type
    MipsOpValue value; /// Operand value of type `type`
    alias value this;  /// Convenient access to value (as in original bindings)

    package this(cs_mips_op internal){
        type = internal.type;
        final switch(internal.type) {
            case MipsOpType.invalid:
                break;
            case MipsOpType.register:
                value.reg = internal.reg;
                break;
            case MipsOpType.immediate:
                value.imm = internal.imm;
                break;
            case MipsOpType.memory:
                value.mem = internal.mem;
                break;
        }
    }
}

/// MIPS-specific information about an instruction
struct MipsInstructionDetail {
    MipsOp[] operands;          /// Operands for this instruction.

    package this(cs_arch_detail arch_detail){
		this(arch_detail.mips);
	}
    package this(cs_mips internal){
        foreach(op; internal.operands[0..internal.op_count])
            operands ~= MipsOp(op);
    }
}

//=============================================================================
// Constants
//=============================================================================

/// Operand type for instruction's operands
enum MipsOpType {
    invalid = 0,  /// Invalid
    register,     /// Register operand (`MipsRegister`)
    immediate,    /// Immediate operand (`long`)
    memory,       /// Memory operand (`MipsOpMem`)
}

/// MIPS registers
enum MipsRegister {
    invalid = 0,
	// General purpose registers
    // TODO: Add the aliases MIPS_REG_0 to MIPS_REG_31 ?
	zero,
	at,
	v0,	v1,
	a0,	a1,	a2,	a3,
    t0, t1, t2, t3, t4, t5, t6, t7,
    s0, s1, s2, s3, s4, s5, s6, s7,
    t8, t9,
    k0, k1,
    gp,
    sp,
    fp,
    ra,

	// DSP registers
	dspccond,
	dspcarry,
	dspefi,
	dspoutflag,
	dspoutflag16_19,
	dspoutflag20,
	dspoutflag21,
	dspoutflag22,
	dspoutflag23,
	dsppos,
	dspscount,

	// ACC registers
	ac0,
	ac1,
	ac2,
	ac3,

	// COP registers
	cc0,
	cc1,
	cc2,
	cc3,
	cc4,
	cc5,
	cc6,
	cc7,

	// FPU registers
	f0,
	f1,
	f2,
	f3,
	f4,
	f5,
	f6,
	f7,
	f8,
	f9,
	f10,
	f11,
	f12,
	f13,
	f14,
	f15,
	f16,
	f17,
	f18,
	f19,
	f20,
	f21,
	f22,
	f23,
	f24,
	f25,
	f26,
	f27,
	f28,
	f29,
	f30,
	f31,

	fcc0,
	fcc1,
	fcc2,
	fcc3,
	fcc4,
	fcc5,
	fcc6,
	fcc7,

	// AFPR128
	w0,
	w1,
	w2,
	w3,
	w4,
	w5,
	w6,
	w7,
	w8,
	w9,
	w10,
	w11,
	w12,
	w13,
	w14,
	w15,
	w16,
	w17,
	w18,
	w19,
	w20,
	w21,
	w22,
	w23,
	w24,
	w25,
	w26,
	w27,
	w28,
	w29,
	w30,
	w31,

	hi,
	lo,

	p0,
	p1,
	p2,

	mpl0,
	mpl1,
	mpl2,

	// alias registers
	hi0 = ac0,
	hi1 = ac1,
	hi2 = ac2,
	hi3 = ac3,

	lo0 = hi0,
	lo1 = hi1,
	lo2 = hi2,
    lo3 = hi3
}

/// MIPS instructions
enum MipsInstructionId {
    invalid = 0,

	absq_s,
	add,
	addiupc,
	addqh,
	addqh_r,
	addq,
	addq_s,
	addsc,
	adds_a,
	adds_s,
	adds_u,
	adduh,
	adduh_r,
	addu,
	addu_s,
	addvi,
	addv,
	addwc,
	add_a,
	addi,
	addiu,
	align_,
	aluipc,
	and,
	andi,
	append,
	asub_s,
	asub_u,
	aui,
	auipc,
	aver_s,
	aver_u,
	ave_s,
	ave_u,
	baddu,
	bal,
	balc,
	balign,
	bc,
	bc0f,
	bc0fl,
	bc0t,
	bc0tl,
	bc1eqz,
	bc1f,
	bc1fl,
	bc1nez,
	bc1t,
	bc1tl,
	bc2eqz,
	bc2f,
	bc2fl,
	bc2nez,
	bc2t,
	bc2tl,
	bc3f,
	bc3fl,
	bc3t,
	bc3tl,
	bclri,
	bclr,
	beq,
	beqc,
	beql,
	beqzalc,
	beqzc,
	bgec,
	bgeuc,
	bgez,
	bgezal,
	bgezalc,
	bgezall,
	bgezals,
	bgezc,
	bgezl,
	bgtz,
	bgtzalc,
	bgtzc,
	bgtzl,
	binsli,
	binsl,
	binsri,
	binsr,
	bitrev,
	bitswap,
	blez,
	blezalc,
	blezc,
	blezl,
	bltc,
	bltuc,
	bltz,
	bltzal,
	bltzalc,
	bltzall,
	bltzals,
	bltzc,
	bltzl,
	bmnzi,
	bmnz,
	bmzi,
	bmz,
	bne,
	bnec,
	bnegi,
	bneg,
	bnel,
	bnezalc,
	bnezc,
	bnvc,
	bnz,
	bovc,
	bposge32,
	break_,
	bseli,
	bsel,
	bseti,
	bset,
	bz,
	beqz,
	b,
	bnez,
	bteqz,
	btnez,
	cache,
	ceil,
	ceqi,
	ceq,
	cfc1,
	cfcmsa,
	cins,
	cins32,
	class_,
	clei_s,
	clei_u,
	cle_s,
	cle_u,
	clo,
	clti_s,
	clti_u,
	clt_s,
	clt_u,
	clz,
	cmpgdu,
	cmpgu,
	cmpu,
	cmp,
	copy_s,
	copy_u,
	ctc1,
	ctcmsa,
	cvt,
	c,
	cmpi,
	dadd,
	daddi,
	daddiu,
	daddu,
	dahi,
	dalign,
	dati,
	daui,
	dbitswap,
	dclo,
	dclz,
	ddiv,
	ddivu,
	deret,
	dext,
	dextm,
	dextu,
	di,
	dins,
	dinsm,
	dinsu,
	div,
	divu,
	div_s,
	div_u,
	dlsa,
	dmfc0,
	dmfc1,
	dmfc2,
	dmod,
	dmodu,
	dmtc0,
	dmtc1,
	dmtc2,
	dmuh,
	dmuhu,
	dmul,
	dmult,
	dmultu,
	dmulu,
	dotp_s,
	dotp_u,
	dpadd_s,
	dpadd_u,
	dpaqx_sa,
	dpaqx_s,
	dpaq_sa,
	dpaq_s,
	dpau,
	dpax,
	dpa,
	dpop,
	dpsqx_sa,
	dpsqx_s,
	dpsq_sa,
	dpsq_s,
	dpsub_s,
	dpsub_u,
	dpsu,
	dpsx,
	dps,
	drotr,
	drotr32,
	drotrv,
	dsbh,
	dshd,
	dsll,
	dsll32,
	dsllv,
	dsra,
	dsra32,
	dsrav,
	dsrl,
	dsrl32,
	dsrlv,
	dsub,
	dsubu,
	ehb,
	ei,
	eret,
	ext,
	extp,
	extpdp,
	extpdpv,
	extpv,
	extrv_rs,
	extrv_r,
	extrv_s,
	extrv,
	extr_rs,
	extr_r,
	extr_s,
	extr,
	exts,
	exts32,
	abs,
	fadd,
	fcaf,
	fceq,
	fclass,
	fcle,
	fclt,
	fcne,
	fcor,
	fcueq,
	fcule,
	fcult,
	fcune,
	fcun,
	fdiv,
	fexdo,
	fexp2,
	fexupl,
	fexupr,
	ffint_s,
	ffint_u,
	ffql,
	ffqr,
	fill,
	flog2,
	floor,
	fmadd,
	fmax_a,
	fmax,
	fmin_a,
	fmin,
	mov,
	fmsub,
	fmul,
	mul,
	neg,
	frcp,
	frint,
	frsqrt,
	fsaf,
	fseq,
	fsle,
	fslt,
	fsne,
	fsor,
	fsqrt,
	sqrt,
	fsub,
	sub,
	fsueq,
	fsule,
	fsult,
	fsune,
	fsun,
	ftint_s,
	ftint_u,
	ftq,
	ftrunc_s,
	ftrunc_u,
	hadd_s,
	hadd_u,
	hsub_s,
	hsub_u,
	ilvev,
	ilvl,
	ilvod,
	ilvr,
	ins,
	insert,
	insv,
	insve,
	j,
	jal,
	jalr,
	jalrs,
	jals,
	jalx,
	jialc,
	jic,
	jr,
	jraddiusp,
	jrc,
	jalrc,
	lb,
	lbux,
	lbu,
	ld,
	ldc1,
	ldc2,
	ldc3,
	ldi,
	ldl,
	ldpc,
	ldr,
	ldxc1,
	lh,
	lhx,
	lhu,
	ll,
	lld,
	lsa,
	luxc1,
	lui,
	lw,
	lwc1,
	lwc2,
	lwc3,
	lwl,
	lwpc,
	lwr,
	lwupc,
	lwu,
	lwx,
	lwxc1,
	li,
	madd,
	maddf,
	maddr_q,
	maddu,
	maddv,
	madd_q,
	maq_sa,
	maq_s,
	maxa,
	maxi_s,
	maxi_u,
	max_a,
	max,
	max_s,
	max_u,
	mfc0,
	mfc1,
	mfc2,
	mfhc1,
	mfhi,
	mflo,
	mina,
	mini_s,
	mini_u,
	min_a,
	min,
	min_s,
	min_u,
	mod,
	modsub,
	modu,
	mod_s,
	mod_u,
	move,
	movf,
	movn,
	movt,
	movz,
	msub,
	msubf,
	msubr_q,
	msubu,
	msubv,
	msub_q,
	mtc0,
	mtc1,
	mtc2,
	mthc1,
	mthi,
	mthlip,
	mtlo,
	mtm0,
	mtm1,
	mtm2,
	mtp0,
	mtp1,
	mtp2,
	muh,
	muhu,
	muleq_s,
	muleu_s,
	mulq_rs,
	mulq_s,
	mulr_q,
	mulsaq_s,
	mulsa,
	mult,
	multu,
	mulu,
	mulv,
	mul_q,
	mul_s,
	nloc,
	nlzc,
	nmadd,
	nmsub,
	nor,
	nori,
	not,
	or,
	ori,
	packrl,
	pause,
	pckev,
	pckod,
	pcnt,
	pick,
	pop,
	precequ,
	preceq,
	preceu,
	precrqu_s,
	precrq,
	precrq_rs,
	precr,
	precr_sra,
	precr_sra_r,
	pref,
	prepend,
	raddu,
	rddsp,
	rdhwr,
	replv,
	repl,
	rint,
	rotr,
	rotrv,
	round,
	sat_s,
	sat_u,
	sb,
	sc,
	scd,
	sd,
	sdbbp,
	sdc1,
	sdc2,
	sdc3,
	sdl,
	sdr,
	sdxc1,
	seb,
	seh,
	seleqz,
	selnez,
	sel,
	seq,
	seqi,
	sh,
	shf,
	shilo,
	shilov,
	shllv,
	shllv_s,
	shll,
	shll_s,
	shrav,
	shrav_r,
	shra,
	shra_r,
	shrlv,
	shrl,
	sldi,
	sld,
	sll,
	slli,
	sllv,
	slt,
	slti,
	sltiu,
	sltu,
	sne,
	snei,
	splati,
	splat,
	sra,
	srai,
	srari,
	srar,
	srav,
	srl,
	srli,
	srlri,
	srlr,
	srlv,
	ssnop,
	st,
	subqh,
	subqh_r,
	subq,
	subq_s,
	subsus_u,
	subsuu_s,
	subs_s,
	subs_u,
	subuh,
	subuh_r,
	subu,
	subu_s,
	subvi,
	subv,
	suxc1,
	sw,
	swc1,
	swc2,
	swc3,
	swl,
	swr,
	swxc1,
	sync,
	syscall,
	teq,
	teqi,
	tge,
	tgei,
	tgeiu,
	tgeu,
	tlbp,
	tlbr,
	tlbwi,
	tlbwr,
	tlt,
	tlti,
	tltiu,
	tltu,
	tne,
	tnei,
	trunc,
	v3mulu,
	vmm0,
	vmulu,
	vshf,
	wait,
	wrdsp,
	wsbh,
	xor,
	xori,

	// some alias instructions
	nop,
	negu,

	// special instructions
	jalr_hb,	// jump and link with Hazard Barrier
    jr_hb,      // jump register with Hazard Barrier
}

/// Group of Mips instructions
enum MipsInstructionGroup {
    invalid = 0,

	// Generic groups
	// All jump instructions (conditional+direct+indirect jumps)
	jump,

	// Architecture-specific groups
	bitcount = 128,
	dsp,
	dspr2,
	fpidx,
	msa,
	mips32r2,
	mips64,
	mips64r2,
	seinreg,
	stdenc,
	swap,
	micromips,
	mips16mode,
	fp64bit,
	nonansfpmath,
	notfp64bit,
	notinmicromips,
	notnacl,
	notmips32r6,
	notmips64r6,
	cnmips,
	mips32,
	mips32r6,
	mips64r6,
	mips2,
	mips3,
	mips3_32,
	mips3_32r2,
	mips4_32,
	mips4_32r2,
	mips5_32r2,
	gp32bit,
    gp64bit
}