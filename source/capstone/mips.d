/// Types and constants of MIPS architecture
module capstone.mips;

import std.conv: to;

import capstone.api;
import capstone.capstone;
import capstone.detail;
import capstone.instruction;
import capstone.instructiongroup;
import capstone.internal;
import capstone.register;
import capstone.utils;

/// Architecture-specific Register variant
class MipsRegister : RegisterImpl!MipsRegisterId {
    package this(in Capstone cs, in int id) {
        super(cs, id);
    }
}

/// Architecture-specific InstructionGroup variant
class MipsInstructionGroup : InstructionGroupImpl!MipsInstructionGroupId {
    package this(in Capstone cs, in int id) {
        super(cs, id);
    }
}

/// Architecture-specific Detail variant
class MipsDetail : DetailImpl!(MipsRegister, MipsInstructionGroup, MipsInstructionDetail) {
    package this(in Capstone cs, cs_detail* internal) {
		super(cs, internal);
	}
}

/// Architecture-specific instruction variant
class MipsInstruction : InstructionImpl!(MipsInstructionId, MipsRegister, MipsDetail) {
    package this(in Capstone cs, cs_insn* internal) {
		super(cs, internal);
	}
}

/// Architecture-specific Capstone variant
class CapstoneMips : CapstoneImpl!(MipsInstructionId, MipsInstruction) {
    /** Creates an architecture-specific instance with a given mode of interpretation
    
    Params:
        modeFlags = The (initial) mode of interpretation, which can still be changed later on
    */
	this(in ModeFlags modeFlags){
        super(Arch.mips, modeFlags);
    }
}

/** Instruction's operand referring to memory

This is associated with the `MipsOpType.mem` operand type
*/
struct MipsOpMem {
    MipsRegister base;   /// Base register (or `MipsRegister.invalid` if irrelevant)
    long disp;           /// Displacement value

	package this(in Capstone cs, mips_op_mem internal) {
		base = new MipsRegister(cs, internal.base);
		disp = internal.disp;
	}
}

/// Union of possible operand types
union MipsOpValue{
    MipsRegister reg;	/// Register
    long imm;			/// Immediate
    MipsOpMem mem;		/// Memory
}

/// Instruction's operand
struct MipsOp {
    MipsOpType type;   /// Operand type
    SafeUnion!MipsOpValue value; /// Operand value of type `type`
    alias value this;  /// Convenient access to value (as in original bindings)

    package this(in Capstone cs, cs_mips_op internal){
        type = internal.type.to!MipsOpType;
        final switch(internal.type) {
            case MipsOpType.invalid:
                break;
            case MipsOpType.reg:
                value.reg = new MipsRegister(cs, internal.reg);
                break;
            case MipsOpType.imm:
                value.imm = internal.imm;
                break;
            case MipsOpType.mem:
                value.mem = MipsOpMem(cs, internal.mem);
                break;
        }
    }
}

/// MIPS-specific information about an instruction
struct MipsInstructionDetail {
    MipsOp[] operands;          /// Operands for this instruction.

    package this(in Capstone cs, cs_arch_detail arch_detail){
        auto internal = arch_detail.mips;
        foreach(op; internal.operands[0..internal.op_count])
            operands ~= MipsOp(cs, op);
    }
}

//=============================================================================
// Constants
//=============================================================================

/// Operand type for instruction's operands
enum MipsOpType {
    invalid = 0,  /// Invalid
    reg,  		  /// Register operand (`MipsRegister`)
    imm,    	  /// Immediate operand (`long`)
    mem,       	  /// Memory operand (`MipsOpMem`)
}

/// MIPS registers
enum MipsRegisterId {
	invalid = 0,
	// General purpose registers
	pc,

	r0,
	r1,
	r2,
	r3,
	r4,
	r5,
	r6,
	r7,
	r8,
	r9,
	r10,
	r11,
	r12,
	r13,
	r14,
	r15,
	r16,
	r17,
	r18,
	r19,
	r20,
	r21,
	r22,
	r23,
	r24,
	r25,
	r26,
	r27,
	r28,
	r29,
	r30,
	r31,

	// DSP registers
	dspccond,
	dspcarry,
	dspefi,
	dspoutflag,
	dspoutflag16_19,
	dspoutflag20,
	dspoutflag21,
	dspoutflag22,
	dspoutflag23,
	dsppos,
	dspscount,

	// ACC registers
	ac0,
	ac1,
	ac2,
	ac3,

	// COP registers
	cc0,
	cc1,
	cc2,
	cc3,
	cc4,
	cc5,
	cc6,
	cc7,

	// FPU registers
	f0,
	f1,
	f2,
	f3,
	f4,
	f5,
	f6,
	f7,
	f8,
	f9,
	f10,
	f11,
	f12,
	f13,
	f14,
	f15,
	f16,
	f17,
	f18,
	f19,
	f20,
	f21,
	f22,
	f23,
	f24,
	f25,
	f26,
	f27,
	f28,
	f29,
	f30,
	f31,

	fcc0,
	fcc1,
	fcc2,
	fcc3,
	fcc4,
	fcc5,
	fcc6,
	fcc7,

	// AFPR128
	w0,
	w1,
	w2,
	w3,
	w4,
	w5,
	w6,
	w7,
	w8,
	w9,
	w10,
	w11,
	w12,
	w13,
	w14,
	w15,
	w16,
	w17,
	w18,
	w19,
	w20,
	w21,
	w22,
	w23,
	w24,
	w25,
	w26,
	w27,
	w28,
	w29,
	w30,
	w31,

	hi,
	lo,

	p0,
	p1,
	p2,

	mpl0,
	mpl1,
	mpl2,

	// alias registers
	zero = r0,
	at = r1,
	v0 = r2,
	v1 = r3,
	a0 = r4,
	a1 = r5,
	a2 = r6,
	a3 = r7,
	t0 = r8,
	t1 = r9,
	t2 = r10,
	t3 = r11,
	t4 = r12,
	t5 = r13,
	t6 = r14,
	t7 = r15,
	s0 = r16,
	s1 = r17,
	s2 = r18,
	s3 = r19,
	s4 = r20,
	s5 = r21,
	s6 = r22,
	s7 = r23,
	t8 = r24,
	t9 = r25,
	k0 = r26,
	k1 = r27,
	gp = r28,
	sp = r29,
	fp = r30,
	s8 = r30,
	ra = r31,

	hi0 = ac0,
	hi1 = ac1,
	hi2 = ac2,
	hi3 = ac3,

	lo0 = hi0,
	lo1 = hi1,
	lo2 = hi2,
	lo3 = hi3,
}

/// MIPS instructions
enum MipsInstructionId {
	invalid = 0,

	absq_s,
	add,
	addiupc,
	addiur1sp,
	addiur2,
	addius5,
	addiusp,
	addqh,
	addqh_r,
	addq,
	addq_s,
	addsc,
	adds_a,
	adds_s,
	adds_u,
	addu16,
	adduh,
	adduh_r,
	addu,
	addu_s,
	addvi,
	addv,
	addwc,
	add_a,
	addi,
	addiu,
	align_,
	aluipc,
	and,
	and16,
	andi16,
	andi,
	append,
	asub_s,
	asub_u,
	aui,
	auipc,
	aver_s,
	aver_u,
	ave_s,
	ave_u,
	b16,
	baddu,
	bal,
	balc,
	balign,
	bbit0,
	bbit032,
	bbit1,
	bbit132,
	bc,
	bc0f,
	bc0fl,
	bc0t,
	bc0tl,
	bc1eqz,
	bc1f,
	bc1fl,
	bc1nez,
	bc1t,
	bc1tl,
	bc2eqz,
	bc2f,
	bc2fl,
	bc2nez,
	bc2t,
	bc2tl,
	bc3f,
	bc3fl,
	bc3t,
	bc3tl,
	bclri,
	bclr,
	beq,
	beqc,
	beql,
	beqz16,
	beqzalc,
	beqzc,
	bgec,
	bgeuc,
	bgez,
	bgezal,
	bgezalc,
	bgezall,
	bgezals,
	bgezc,
	bgezl,
	bgtz,
	bgtzalc,
	bgtzc,
	bgtzl,
	binsli,
	binsl,
	binsri,
	binsr,
	bitrev,
	bitswap,
	blez,
	blezalc,
	blezc,
	blezl,
	bltc,
	bltuc,
	bltz,
	bltzal,
	bltzalc,
	bltzall,
	bltzals,
	bltzc,
	bltzl,
	bmnzi,
	bmnz,
	bmzi,
	bmz,
	bne,
	bnec,
	bnegi,
	bneg,
	bnel,
	bnez16,
	bnezalc,
	bnezc,
	bnvc,
	bnz,
	bovc,
	bposge32,
	break_,
	break16,
	bseli,
	bsel,
	bseti,
	bset,
	bz,
	beqz,
	b,
	bnez,
	bteqz,
	btnez,
	cache,
	ceil,
	ceqi,
	ceq,
	cfc1,
	cfcmsa,
	cins,
	cins32,
	class_,
	clei_s,
	clei_u,
	cle_s,
	cle_u,
	clo,
	clti_s,
	clti_u,
	clt_s,
	clt_u,
	clz,
	cmpgdu,
	cmpgu,
	cmpu,
	cmp,
	copy_s,
	copy_u,
	ctc1,
	ctcmsa,
	cvt,
	c,
	cmpi,
	dadd,
	daddi,
	daddiu,
	daddu,
	dahi,
	dalign,
	dati,
	daui,
	dbitswap,
	dclo,
	dclz,
	ddiv,
	ddivu,
	deret,
	dext,
	dextm,
	dextu,
	di,
	dins,
	dinsm,
	dinsu,
	div,
	divu,
	div_s,
	div_u,
	dlsa,
	dmfc0,
	dmfc1,
	dmfc2,
	dmod,
	dmodu,
	dmtc0,
	dmtc1,
	dmtc2,
	dmuh,
	dmuhu,
	dmul,
	dmult,
	dmultu,
	dmulu,
	dotp_s,
	dotp_u,
	dpadd_s,
	dpadd_u,
	dpaqx_sa,
	dpaqx_s,
	dpaq_sa,
	dpaq_s,
	dpau,
	dpax,
	dpa,
	dpop,
	dpsqx_sa,
	dpsqx_s,
	dpsq_sa,
	dpsq_s,
	dpsub_s,
	dpsub_u,
	dpsu,
	dpsx,
	dps,
	drotr,
	drotr32,
	drotrv,
	dsbh,
	dshd,
	dsll,
	dsll32,
	dsllv,
	dsra,
	dsra32,
	dsrav,
	dsrl,
	dsrl32,
	dsrlv,
	dsub,
	dsubu,
	ehb,
	ei,
	eret,
	ext,
	extp,
	extpdp,
	extpdpv,
	extpv,
	extrv_rs,
	extrv_r,
	extrv_s,
	extrv,
	extr_rs,
	extr_r,
	extr_s,
	extr,
	exts,
	exts32,
	abs,
	fadd,
	fcaf,
	fceq,
	fclass,
	fcle,
	fclt,
	fcne,
	fcor,
	fcueq,
	fcule,
	fcult,
	fcune,
	fcun,
	fdiv,
	fexdo,
	fexp2,
	fexupl,
	fexupr,
	ffint_s,
	ffint_u,
	ffql,
	ffqr,
	fill,
	flog2,
	floor,
	fmadd,
	fmax_a,
	fmax,
	fmin_a,
	fmin,
	mov,
	fmsub,
	fmul,
	mul,
	neg,
	frcp,
	frint,
	frsqrt,
	fsaf,
	fseq,
	fsle,
	fslt,
	fsne,
	fsor,
	fsqrt,
	sqrt,
	fsub,
	sub,
	fsueq,
	fsule,
	fsult,
	fsune,
	fsun,
	ftint_s,
	ftint_u,
	ftq,
	ftrunc_s,
	ftrunc_u,
	hadd_s,
	hadd_u,
	hsub_s,
	hsub_u,
	ilvev,
	ilvl,
	ilvod,
	ilvr,
	ins,
	insert,
	insv,
	insve,
	j,
	jal,
	jalr,
	jalrs16,
	jalrs,
	jals,
	jalx,
	jialc,
	jic,
	jr,
	jr16,
	jraddiusp,
	jrc,
	jalrc,
	lb,
	lbu16,
	lbux,
	lbu,
	ld,
	ldc1,
	ldc2,
	ldc3,
	ldi,
	ldl,
	ldpc,
	ldr,
	ldxc1,
	lh,
	lhu16,
	lhx,
	lhu,
	li16,
	ll,
	lld,
	lsa,
	luxc1,
	lui,
	lw,
	lw16,
	lwc1,
	lwc2,
	lwc3,
	lwl,
	lwm16,
	lwm32,
	lwpc,
	lwp,
	lwr,
	lwupc,
	lwu,
	lwx,
	lwxc1,
	lwxs,
	li,
	madd,
	maddf,
	maddr_q,
	maddu,
	maddv,
	madd_q,
	maq_sa,
	maq_s,
	maxa,
	maxi_s,
	maxi_u,
	max_a,
	max,
	max_s,
	max_u,
	mfc0,
	mfc1,
	mfc2,
	mfhc1,
	mfhi,
	mflo,
	mina,
	mini_s,
	mini_u,
	min_a,
	min,
	min_s,
	min_u,
	mod,
	modsub,
	modu,
	mod_s,
	mod_u,
	move,
	movep,
	movf,
	movn,
	movt,
	movz,
	msub,
	msubf,
	msubr_q,
	msubu,
	msubv,
	msub_q,
	mtc0,
	mtc1,
	mtc2,
	mthc1,
	mthi,
	mthlip,
	mtlo,
	mtm0,
	mtm1,
	mtm2,
	mtp0,
	mtp1,
	mtp2,
	muh,
	muhu,
	muleq_s,
	muleu_s,
	mulq_rs,
	mulq_s,
	mulr_q,
	mulsaq_s,
	mulsa,
	mult,
	multu,
	mulu,
	mulv,
	mul_q,
	mul_s,
	nloc,
	nlzc,
	nmadd,
	nmsub,
	nor,
	nori,
	not16,
	not,
	or,
	or16,
	ori,
	packrl,
	pause,
	pckev,
	pckod,
	pcnt,
	pick,
	pop,
	precequ,
	preceq,
	preceu,
	precrqu_s,
	precrq,
	precrq_rs,
	precr,
	precr_sra,
	precr_sra_r,
	pref,
	prepend,
	raddu,
	rddsp,
	rdhwr,
	replv,
	repl,
	rint,
	rotr,
	rotrv,
	round,
	sat_s,
	sat_u,
	sb,
	sb16,
	sc,
	scd,
	sd,
	sdbbp,
	sdbbp16,
	sdc1,
	sdc2,
	sdc3,
	sdl,
	sdr,
	sdxc1,
	seb,
	seh,
	seleqz,
	selnez,
	sel,
	seq,
	seqi,
	sh,
	sh16,
	shf,
	shilo,
	shilov,
	shllv,
	shllv_s,
	shll,
	shll_s,
	shrav,
	shrav_r,
	shra,
	shra_r,
	shrlv,
	shrl,
	sldi,
	sld,
	sll,
	sll16,
	slli,
	sllv,
	slt,
	slti,
	sltiu,
	sltu,
	sne,
	snei,
	splati,
	splat,
	sra,
	srai,
	srari,
	srar,
	srav,
	srl,
	srl16,
	srli,
	srlri,
	srlr,
	srlv,
	ssnop,
	st,
	subqh,
	subqh_r,
	subq,
	subq_s,
	subsus_u,
	subsuu_s,
	subs_s,
	subs_u,
	subu16,
	subuh,
	subuh_r,
	subu,
	subu_s,
	subvi,
	subv,
	suxc1,
	sw,
	sw16,
	swc1,
	swc2,
	swc3,
	swl,
	swm16,
	swm32,
	swp,
	swr,
	swxc1,
	sync,
	synci,
	syscall,
	teq,
	teqi,
	tge,
	tgei,
	tgeiu,
	tgeu,
	tlbp,
	tlbr,
	tlbwi,
	tlbwr,
	tlt,
	tlti,
	tltiu,
	tltu,
	tne,
	tnei,
	trunc,
	v3mulu,
	vmm0,
	vmulu,
	vshf,
	wait,
	wrdsp,
	wsbh,
	xor,
	xor16,
	xori,

	// some alias instructions
	nop,
	negu,

	// special instructions
	jalr_hb, /// Jump and link with hazard barrier
	jr_hb, 	 /// Jump register with Hazard Barrier
}

/// Group of Mips instructions
enum MipsInstructionGroupId {
	invalid = 0,

	// Generic groups
	// All jump instructions (conditional+direct+indirect jumps)
	jump,
	// All call instructions
	call,
	// All return instructions
	ret,
	// All interrupt instructions (int+syscall)
	int_,
	// All interrupt return instructions
	iret,
	// All privileged instructions
	privilege,
	// All relative branching instructions
	branch_relative,

	// Architecture-specific groups
	bitcount = 128,
	dsp,
	dspr2,
	fpidx,
	msa,
	mips32r2,
	mips64,
	mips64r2,
	seinreg,
	stdenc,
	swap,
	micromips,
	mips16mode,
	fp64bit,
	nonansfpmath,
	notfp64bit,
	notinmicromips,
	notnacl,
	notmips32r6,
	notmips64r6,
	cnmips,
	mips32,
	mips32r6,
	mips64r6,
	mips2,
	mips3,
	mips3_32,
	mips3_32r2,
	mips4_32,
	mips4_32r2,
	mips5_32r2,
	gp32bit,
	gp64bit,
}